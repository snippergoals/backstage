import { resolve as resolvePath } from 'path';
import { existsSync, realpathSync } from 'fs';

const findPaths = () => {
  const appDir = realpathSync(process.cwd());
  const resolveApp = (path: string) => resolvePath(appDir, path);
  const resolveOwn = (path: string) => resolvePath(__dirname, '..', path);
  const resolveAppModule = (path: string) => {
    for (const ext of ['mjs', 'js', 'ts', 'tsx', 'jsx']) {
      const filePath = resolveApp(`${path}.${ext}`);
      if (existsSync(filePath)) {
        return filePath;
      }
    }
    return resolveApp(`${path}.js`);
  };

  let appHtml = resolveApp('dev/index.html');
  if (!existsSync(appHtml)) {
    appHtml = resolveOwn('../templates/serve_index.html');
  }

  return {
    appHtml,
    appPath: resolveApp('.'),
    appAssets: resolveApp('assets'),
    appSrc: [resolveApp('src'), resolveApp('dev')],
    appIndexJs: resolveAppModule('dev/index'),
    appTsConfig: resolveApp('tsconfig.json'),
    appNodeModules: resolveApp('node_modules'),
    appPackageJson: resolveApp('package.json'),
    publicUrlOrPath: '/',
  };
};

/**
 * Webpack is a pain, react-scripts almost has what we want, but we need
 * a separate entrypoint (dev/index) and would like to not force the plugin to
 * have a index html template.
 * Reconfiguring react-scripts is a pain, so the code in this function is the
 * serve script inside react-scripts, but cleaned based on a couple of assumptions we make.
 */
export default async () => {
  process.env.BABEL_ENV = 'development';
  process.env.NODE_ENV = 'development';

  // Load our own and then override react-scripts paths before loading other modules
  const reactScriptsPaths = require('react-scripts/config/paths');
  const paths = findPaths();
  Object.assign(reactScriptsPaths, paths);

  const chalk = require('react-dev-utils/chalk');
  const webpack = require('react-scripts/node_modules/webpack');
  const WebpackDevServer = require('react-scripts/node_modules/webpack-dev-server');
  const clearConsole = require('react-dev-utils/clearConsole');
  const {
    choosePort,
    createCompiler,
    prepareUrls,
  } = require('react-dev-utils/WebpackDevServerUtils');
  const openBrowser = require('react-dev-utils/openBrowser');
  const configFactory = require('react-scripts/config/webpack.config');
  const createDevServerConfig = require('react-scripts/config/webpackDevServer.config');

  const useYarn = true;
  const useTypeScript = true;
  const isInteractive = process.stdout.isTTY;

  const DEFAULT_PORT = parseInt(process.env.PORT ?? '', 10) || 3000;
  const HOST = process.env.HOST || '0.0.0.0';

  if (process.env.HOST) {
    console.log(
      chalk.cyan(
        `Attempting to bind to HOST environment variable: ${chalk.yellow(
          chalk.bold(process.env.HOST),
        )}`,
      ),
    );
    console.log(
      `If this was unintentional, check that you haven't mistakenly set it in your shell.`,
    );
    console.log(
      `Learn more here: ${chalk.yellow('https://bit.ly/CRA-advanced-config')}`,
    );
    console.log();
  }

  const port = await choosePort(HOST, DEFAULT_PORT);
  if (port == null) {
    return;
  }

  const config = configFactory('development');
  const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
  const appName = require(paths.appPackageJson).name;
  const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === 'true';
  const urls = prepareUrls(
    protocol,
    HOST,
    port,
    paths.publicUrlOrPath.slice(0, -1),
  );

  const devSocket = {
    warnings: (warnings: any) =>
      devServer.sockWrite(devServer.sockets, 'warnings', warnings),
    errors: (errors: any) =>
      devServer.sockWrite(devServer.sockets, 'errors', errors),
  };

  // Create a webpack compiler that is configured with custom messages.
  const compiler = createCompiler({
    appName,
    config,
    devSocket,
    urls,
    useYarn,
    useTypeScript,
    tscCompileOnError,
    webpack,
  });

  // Serve webpack assets generated by the compiler over a web server.
  const serverConfig = createDevServerConfig(undefined, urls.lanUrlForConfig);
  const devServer = new WebpackDevServer(compiler, serverConfig);

  // Launch WebpackDevServer.
  devServer.listen(port, HOST, (err?: Error) => {
    if (err) {
      return console.log(err);
    }
    if (isInteractive) {
      clearConsole();
    }

    console.log(chalk.cyan('Starting the development server...\n'));
    openBrowser(urls.localUrlForBrowser);
  });

  const sigHandler = () => {
    devServer.close();
    process.exit();
  };
  process.on('SIGINT', sigHandler);
  process.on('SIGTERM', sigHandler);

  if (isInteractive) {
    // Gracefully exit when stdin ends
    process.stdin.on('end', function() {
      devServer.close();
      process.exit();
    });
    process.stdin.resume();
  }
};
