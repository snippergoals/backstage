/*
 * Copyright 2020 Spotify AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { execSync } from 'child_process';
import MarkdownPrinter from './MarkdownPrinter';
import sortSelector from './sortSelector';
import { ApiDoc } from './types';

const GH_BASE_URL = 'https://github.com/spotify/backstage';

const COMMIT_SHA =
  process.env.COMMIT_SHA || execSync('git rev-parse HEAD').toString('utf8');

/**
 * The ApiDocPrinter takes a ApiDoc data structure, typically generated by an ApiDocGenerator,
 * and prints it out as a markdown doc with custom code highlighting and links.
 */
export default class ApiDocPrinter {
  printerFactory: () => MarkdownPrinter;

  constructor(printerFactory: () => MarkdownPrinter) {
    this.printerFactory = printerFactory;
  }

  mkTypeLink({ file, lineInFile }: { file: string; lineInFile: number }) {
    const text = `${file}:${lineInFile}`;
    const href = `${GH_BASE_URL}/blob/${COMMIT_SHA}/${file}#L${lineInFile}`;
    return `[${text}](${href}){:target="_blank"}`;
  }

  print(apiDoc: ApiDoc): Buffer {
    const printer = this.printerFactory();

    // Remove line numbers from codeblocks
    printer.style('.linenodiv{ display: none }');

    printer.header(1, `shared/apis/${apiDoc.id}`);

    const ifInfo = apiDoc.interfaceInfo;

    if (ifInfo.docs.length) {
      for (const doc of ifInfo.docs) {
        printer.text(doc);
      }
    } else {
      printer.paragraph(apiDoc.description);
    }

    printer.header(2, 'API Interface');
    printer.paragraph(
      `The API interface type is defined at ${this.mkTypeLink(ifInfo)} as ${
        ifInfo.name
      }.`,
    );
    printer.paragraph('All members of the interface are listed below.');

    for (const member of ifInfo.members) {
      printer.header(
        3,
        `${member.name}${member.type === 'method' ? '()' : ''}`,
        member.path,
      );

      for (const doc of member.docs) {
        printer.text(doc);
      }

      printer.codeWithLinks(member);
    }

    if (ifInfo.dependentTypes.length) {
      printer.header(2, 'Types');
    }
    for (const type of ifInfo.dependentTypes
      .slice()
      .sort(sortSelector(x => x.name))) {
      printer.header(3, `${type.name}`, type.path);

      for (const doc of type.docs) {
        printer.text(doc);
      }
      printer.codeWithLinks(type);

      printer.paragraph(`Defined at ${this.mkTypeLink(type)}.`);

      const usageLinks = [...ifInfo.members, ...ifInfo.dependentTypes]
        .filter(member => {
          return member.links.some(link => link.id === type.id);
        })
        .map(({ name, path }) => `[${name}](#${path})`);

      if (usageLinks.length) {
        printer.paragraph(`Referenced by: ${usageLinks.join(', ')}.`);
      }
    }

    return printer.toBuffer();
  }
}
