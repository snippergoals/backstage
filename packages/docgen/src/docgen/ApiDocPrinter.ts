/*
 * Copyright 2020 Spotify AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { execSync } from 'child_process';
import MarkdownPrinter from './MarkdownPrinter';
import sortSelector from './sortSelector';
import { ApiDoc, InterfaceInfo } from './types';

// TODO(Rugvip): provide through options?
const GH_BASE_URL = 'https://github.com/spotify/backstage';

const COMMIT_SHA =
  process.env.COMMIT_SHA || execSync('git rev-parse HEAD').toString('utf8');

/**
 * The ApiDocPrinter takes a ApiDoc data structure, typically generated by an ApiDocGenerator,
 * and prints it out as a markdown doc with custom code highlighting and links.
 */
export default class ApiDocPrinter {
  printerFactory: () => MarkdownPrinter;

  constructor(printerFactory: () => MarkdownPrinter) {
    this.printerFactory = printerFactory;
  }

  mkLink(
    { file, lineInFile }: { file: string; lineInFile: number },
    text?: string,
  ) {
    const linkText = text ?? `${file}:${lineInFile}`;
    const href = `${GH_BASE_URL}/blob/${COMMIT_SHA}/${file}#L${lineInFile}`;
    return `[${linkText}](${href}){:target="_blank"}`;
  }

  print(apiDoc: ApiDoc): Buffer {
    const printer = this.printerFactory();

    // Remove line numbers from codeblocks
    printer.style('.linenodiv{ display: none }');

    printer.header(1, apiDoc.id);

    const ifInfo = apiDoc.interfaceInfos[0];

    if (ifInfo.docs.length) {
      for (const doc of ifInfo.docs) {
        printer.text(doc);
      }
    } else {
      printer.paragraph(apiDoc.description);
    }

    printer.header(2, 'API Interface');
    printer.paragraph(
      `The API interface type is defined at ${this.mkLink(ifInfo)} as ${
        ifInfo.name
      }.`,
    );
    printer.paragraph('All members of the interface are listed below.');

    this.addInterfaceMembers(printer, ifInfo);

    if (ifInfo.dependentTypes.length) {
      printer.header(2, 'Types');

      this.addInterfaceTypes(printer, ifInfo);
    }

    return printer.toBuffer();
  }

  printApiIndex(apiDocs: ApiDoc[]): Buffer {
    const printer = this.printerFactory();

    printer.header(1, 'Backstage Utility APIs');

    printer.paragraph(
      'The following is a list of all Utility APIs defined by `@backstage/core`.',
      'They are available to use by plugins and components, and need to be provided by the app',
      'They can be accessed using the `useApi` hook, also provided by `@backstage/core`.',
      'For more information, see https://github.com/spotify/backstage/blob/master/docs/api/utility-apis.md.',
    );

    for (const api of apiDocs) {
      printer.header(3, `${api.name.replace(/ApiRef$/, '')}`, api.id);

      printer.paragraph(api.description);

      const typeLinks = api.interfaceInfos.map(i => `[${i.name}](${i.name})`);
      printer.paragraph(
        `Implemented type${typeLinks.length > 1 ? 's' : ''}: ${typeLinks.join(
          ', ',
        )}`,
      );

      printer.paragraph(`ApiRef: ${this.mkLink(api, api.name)}`);
    }

    return printer.toBuffer();
  }

  printInterface(apiType: InterfaceInfo, apiDocs: ApiDoc[]): Buffer {
    const printer = this.printerFactory();

    // Remove line numbers from codeblocks
    printer.style('.linenodiv{ display: none }');

    printer.header(1, apiType.name);

    printer.paragraph(
      `The ${apiType.name} type is defined at ${this.mkLink(apiType)}.`,
    );

    const apiLinks = apiDocs
      .filter(ad => ad.interfaceInfos.some(i => i.name === apiType.name))
      .map(ad => `[${ad.name}](../#${ad.id})`);

    if (apiLinks.length === 1) {
      printer.paragraph(
        `The following Utility API implements this type: ${apiLinks}`,
      );
    } else {
      printer.paragraph(`The following Utility APIs implement this type:`);
      for (const link of apiLinks) {
        printer.text(`  - ${link}`);
      }
    }

    printer.header(2, 'Members');

    this.addInterfaceMembers(printer, apiType);

    if (apiType.dependentTypes.length) {
      printer.header(2, 'Supporting types');
      printer.paragraph(
        'These types are part of the API declaration, but may not be unique to this API.',
      );

      this.addInterfaceTypes(printer, apiType);
    }

    return printer.toBuffer();
  }

  private addInterfaceMembers(
    printer: MarkdownPrinter,
    apiType: InterfaceInfo,
  ) {
    for (const member of apiType.members) {
      printer.header(
        3,
        `${member.name}${member.type === 'method' ? '()' : ''}`,
        member.path,
      );

      for (const doc of member.docs) {
        printer.text(doc);
      }

      printer.codeWithLinks(member);
    }
  }

  private addInterfaceTypes(printer: MarkdownPrinter, apiType: InterfaceInfo) {
    for (const type of apiType.dependentTypes
      .slice()
      .sort(sortSelector(x => x.name))) {
      printer.header(3, `${type.name}`, type.path);

      for (const doc of type.docs) {
        printer.text(doc);
      }
      printer.codeWithLinks(type);

      printer.paragraph(`Defined at ${this.mkLink(type)}.`);

      const usageLinks = [...apiType.members, ...apiType.dependentTypes]
        .filter(member => {
          return member.links.some(link => link.id === type.id);
        })
        .map(({ name, path }) => `[${name}](#${path})`);

      if (usageLinks.length) {
        printer.paragraph(`Referenced by: ${usageLinks.join(', ')}.`);
      }
    }
  }
}
